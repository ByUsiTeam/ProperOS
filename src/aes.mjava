import java.io.*;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public String md5(byte[] btInput) {
  
  char[] hexDigits = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
  
  try {
    
    java.security.MessageDigest mdInst = java.security.MessageDigest.getInstance("MD5");
    
    mdInst.update(btInput);
    
    byte[] md = mdInst.digest();
    
    int j = md.length;
    
    char[] str = new char[j * 2];
    
    int k = 0;
    
    for (int i = 0; i < j; i++) {
      
      byte byte0 = md[i];
      
      str[k++] = hexDigits[byte0 >>> 4 & 0xf];
      
      str[k++] = hexDigits[byte0 & 0xf];
      
    }
    
    return new String(str);
    
  } catch (java.lang.Exception e) {
    
    e.printStackTrace();
    
    return null;
    
  }
  
}



/**

* md5加密
，输入字符串

* */

public String md5st(String btInput) {
  md5(btInput.getBytes());
  
}



/**

* AES加密， 输入字节组 和 一个自定义密钥。输出加密字符

*/

public String encrypt(byte[] st, String key)

{
  
  javax.crypto.Cipher localCipher = null;
  
  try {
    
    localCipher = javax.crypto.Cipher.getInstance("AES/CBC/PKCS5Padding");
    
  } catch (java.lang.Exception e) {
    
    e.printStackTrace();
    
  }
  
  if(localCipher != null)
  
  {
    
    try {
      
      localCipher.init(1, new javax.crypto.spec.SecretKeySpec(key.getBytes(), "AES"), new javax.crypto.spec.IvParameterSpec(key.getBytes()));
      
      return android.util.Base64.encodeToString(localCipher.doFinal(st), 4).trim();
      
    } catch (java.lang.Exception e) {
      
      e.printStackTrace();
      
    }
    
  }
  
  return null;
  
}

/**

* AES解密， 输入加密字符 和 一个自定义密钥。输出字节组

*/

public byte[] decrypt(String st, String key)

{
  
  javax.crypto.Cipher localCipher = null;
  
  try {
    
    localCipher = javax.crypto.Cipher.getInstance("AES/CBC/PKCS5Padding");
    
  } catch (java.lang.Exception e) {
    
    e.printStackTrace();
    
  }
  
  if(localCipher != null)
  
  {
    
    try {
      
      localCipher.init(2, new javax.crypto.spec.SecretKeySpec(key.getBytes(), "AES"), new javax.crypto.spec.IvParameterSpec(key.getBytes()));
      
      return localCipher.doFinal(android.util.Base64.decode(st, 4));
      
    } catch (java.lang.Exception e) {
      
      e.printStackTrace();
      
    }
    
  }
  
  return null;
  
}

/**

* 获取文件字节组， 输入文件绝对路径。输出文件字节组

*/

public byte[] toFileByte(String file) {
  
  java.io.File f = new java.io.File(file);
  
  if(!f.exists())
  
  return null;
  
  java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream((int) f.length());
  
  java.io.BufferedInputStream in = null;
  
  byte[] b = null;
  
  try {
    
    in = new java.io.BufferedInputStream(new java.io.FileInputStream(f));
    
    int buf_size = 1024;
    
    byte[] buffer = new byte[buf_size];
    
    int len = 0;
    
    while (-1 != (len = in.read(buffer, 0, buf_size))) {
      
      bos.write(buffer, 0, len);
      
    }
    
    b = bos.toByteArray();
    
  } catch (java.lang.Exception e) {
    
    e.printStackTrace();
    
  } finally {
    
    try {
      
      in.close();
      
    } catch (java.lang.Exception e) {
      
      e.printStackTrace();
      
    }
    
    try {
      
      bos.close();
      
    } catch (java.lang.Exception e) {
      
      e.printStackTrace();
      
    }
    
  }
  
  return b;
  
}

/**

* 写入字节组至文件。输入文件绝对路径 和 输入字节组， 输出是否成功

*  注意， 这里的文件绝对路径 如果目录或文件夹会保存失败

*/

public boolean writebyteFile(String filename, byte[] b) {
  
  boolean s = true;
  
  java.io.FileOutputStream fos = null;
  
  java.io.File f = new java.io.File(filename);
  
  
  
  if (f.exists())
  
  f.delete();
  
  try {
    
    fos = new java.io.FileOutputStream(f);
    
  } catch (java.lang.Exception e) {
    
    e.printStackTrace();
    
    return false;
    
  }
  
  try {
    
    fos.write(b, 0, b.length);
    
  } catch (java.lang.Exception e) {
    
    s = false;
    
    e.printStackTrace();
    
  }
  
  try {
    
    fos.close();
    
  } catch (java.lang.Exception e) {
    
    s = false;
    
    e.printStackTrace();
    
  }
  
  return s;
  
}





/**

* AES加密， 输入原字符串 和 一个自定义密钥。输出加密字符串

*/

public String encryptString(String st, String key)

{
  
  return encrypt(st.getBytes(), md5st(key).substring(16));
  
}
/**

* AES解密， 输入加密字符 和 一个自定义密钥。输出原字符串

*/

public String decryptString(String st, String key)

{
  
    return new String(decrypt(st, md5st(key).substring(16)));
  
}
/**

* AES加密， 输入原字符串 和 一个自定义16位密钥。输出加密字符串

*/

public String encryptString16(String st, String key)

{
  
  return encrypt(st.getBytes(), key);
  
}

/**

* AES解密， 输入加密字符 和 一个自定义16位密钥。输出原字符串

*/

public String decryptString16(String st, String key)

{
  try{
    return new String(decrypt(st, key));
  }catch (IOException e) {
    e.printStackTrace();
    return null;
  }
}



/**

* AES加密，文件加密。 输入原文件路径 和 输入加密后文件路径 和 自定义密钥

*/

public boolean encryptFile(String file, String savefile, String key)

{
  
  java.io.File f = new java.io.File(file);
  
  if (!f.exists())
  
  return false;
  
  writebyteFile(savefile, encrypt(toFileByte(file), md5st(key).substring(16)).getBytes());
  
  return true;
  
}



/**

* AES解密，文件解密。 输入加密后文件路径 和 输入解密后文件路径 和 自定义密钥

*/

public boolean decryptFile(String file, String savefile, String key)

{
  
  java.io.File f = new java.io.File(file);
  
  if (!f.exists())
  
  return false;
  
  writebyteFile(savefile, decrypt(new String(toFileByte(file)), md5st(key).substring(16)));
  
  return true;
  
}

/**

* AES加密，文件加密。 输入原文件路径 和 输入加密后文件路径 和 自定义密钥

*/

public boolean encryptFile16(String file, String savefile, String key)

{
  
  java.io.File f = new java.io.File(file);
  
  if (!f.exists())
  
  return false;
  
  writebyteFile(savefile, encrypt(toFileByte(file), key).getBytes());
  
  return true;
  
}



/**

* AES解密，文件解密。 输入加密后文件路径 和 输入解密后文件路径 和 自定义密钥

*/

public boolean decryptFile16(String file, String savefile, String key)

{
  
  java.io.File f = new java.io.File(file);
  
  if (!f.exists())
  
  return false;
  
  writebyteFile(savefile, decrypt(new String(toFileByte(file)), key));
  
  return true;
  
}